# Generating and Running Tests for UDP

In parseLab, there is the concept of "Testcase" generation and "Test" generation.
In this walk-through, we will work with "Test" generation, which leverages the output of "Testcase" generation.
If you have not yet produced any testcase directories, please refer to the [guide for UDP](./UDP_testcase_generation.md) before continuing with this guide.

Test generation logic comes from parseLab genrator modules, which are capable of producing the source code nessary for passing data into a supplied parser.

## Setup

The reference for UDP that we will use for this walk-through can be found [here](https://en.wikipedia.org/wiki/User_Datagram_Protocol#UDP_datagram_structure).
Along with that, we will be using the testcases generated by [this walk-through](./UDP_testcase_generation.md) and the parser generated with [this walk-through](./UDP_protocol_specification.md)

**NOTE: It is required that you have generated a parser already before you attempt to generate test code!**

For this walk-through, we will be using the parseLab generator module for Hammer.


## Generating the Test Code

To generate the test code that takes testcase data and passes it into a Hammer parser, we use the `bin/generate_test.py` driver script.
We will need to pass a few arguments into the script so that it can target a specific parseLab module, protocol specification, and testcase.

Since we are leveraging the testcase created in the [UDP Testcase Guide](./UDP_testcase_generation.md), we can pass in the valid testcase with a single message instance.

```bash
# Go to the parselab/bin directory
cd ${PARSELAB_TOP}/bin

# Ensure that a Hammer parser already exists for UDP
#  This should not be an empty directory!
#  Follow the UDP protocol specification guide to create this directory
ls ../protocols/udp/hammer/out

# Run the test code generator
./generate_test.py --protocol ../protocols/udp \
                   --module hammer \
                   --testcase ../protocols/udp/testcases/valid_docs_test_1
```

Upon successul generation of the test code, the printed statment should depict that there were three files generated: `test.c`, `data.c`, and `data.h`.
These three files are what the Hammer parseLab module generator uses to contain all the necessary logic and data for the test.

These files are generated because the `generate_test.py` driver will reach out to a loaded parseLab generator module and run a few interface calls that the generator modules are expected to have.
Every parseLab generator module will have these interface functions for the drivers to leverage when loading them.

The output will be different for every different parseLab module, but it is assumed that there will always be a tangible list of files that are needed to represent test code.
Becuase this is a walk through on using parseLab rather than the Hammer generator module, we will not focus on the generated files or their contents, but it is important to note that they are C source files and headers.


## Running the Test Code

Now that there are some source code files, we can run the tests and observe the success/failure when we run the tests against our generated parser.

Sometimes, the source code that is generated is executable, and running the tests is as simple as running them directlry; in the case of Hammer, the output is C source code.
Since the Hammer parser library is written for C, before it can be ran, it must be compiled.
As referenced before, the driver makes a call to the Hammer module's `run_test()` interface function, which is responsible for handling all the logic for getting that generated test code to run.
For the sake of the Hammer module, that means it must first compile it, then execute it, all within the `run_test()` call.

Much like the test generator driver, we will need to pass in some arguments to point the driver at the correct information.

```bash
# Go to the parselab/bin directory
cd ${PARSELAB_TOP}/bin

# Run the test runner driver
./run_test --protocol ../protocols/udp \
           --module hammer \
           --testcase ../protocols/udp/testcases/valid_docs_test_1

> [PASS] Message (0000_UDP_MESSAGE) was correctly accepted by parser
```

The Hammer test code that is generated will provide a visible status for each message that goes through the parser.
It is important to note that this behavior is defined by the Hammer generator module, not parseLab-proper.

We have just ran through running the test of a valid testcase, which means that we expect that the parser would accept the input of all the messages in the testcase.
Now, we are going to run through the other, invalid, testcase that we generated for UDP.

## Generating and Running the Invalid Testcase

```bash
# Go to the parselab/bin directory
cd ${PARSELAB_TOP}/bin

# Generate the test code for the invalid testcase
./generate_test.py --protocol ../protocols/udp \
                   --module hammer \
                   --testcase ../protocols/udp/testcases/invalid_docs_test_1

# Run the test runner driver
./run_test --protocol ../protocols/udp \
           --module hammer \
           --testcase ../protocols/udp/testcases/invalid_docs_test_1

> [PASS] Message (0000_UDP_MESSAGE) was correctly rejected by parser
> [PASS] Message (0000_UDP_MESSAGE) was correctly rejected by parser
> [PASS] Message (0001_UDP_MESSAGE) was correctly rejected by parser
> [PASS] Message (0002_UDP_MESSAGE) was correctly rejected by parser
> [PASS] Message (0003_UDP_MESSAGE) was correctly rejected by parser
> [PASS] Message (0004_UDP_MESSAGE) was correctly rejected by parser
> [PASS] Message (0005_UDP_MESSAGE) was correctly rejected by parser
> [PASS] Message (0006_UDP_MESSAGE) was correctly rejected by parser
> [PASS] Message (0007_UDP_MESSAGE) was correctly rejected by parser
> [PASS] Message (0008_UDP_MESSAGE) was correctly rejected by parser
> [PASS] Message (0009_UDP_MESSAGE) was correctly rejected by parser
> [PASS] Message (0010_UDP_MESSAGE) was correctly rejected by parser
> [PASS] Message (0011_UDP_MESSAGE) was correctly rejected by parser
> [PASS] Message (0012_UDP_MESSAGE) was correctly rejected by parser
> [PASS] Message (0013_UDP_MESSAGE) was correctly rejected by parser
> [PASS] Message (0014_UDP_MESSAGE) was correctly rejected by parser
```

Observe the change in the verbage; `was correctly rejected` is the PASS statement, rather than `was correctly accepted` like in the valid testcase.

If something were to have gone wrong, and the parseLab module didn't properly generate a parser, then the test would fail with an opposite response statement.
For example, `[FAIL] Message (0000_UDP_MESSAGE) was incorrectly rejected by parser`, which denotes that the parser rejected it, but the testcase was valid and should have been accepted by the parser.

## Why Use the Testcase/Test System?

Since parseLab is a framework for building code generators for parsing libraries, running these tests will give insight toward what capabilities that a parseLab generator module is not working fully.
For example, if you run a series of tests and see that only message fields with non-byte aligned values are failing, it might be that your parser generator logic is not properly generating the parsing rules to handle this case.

[Next we will discuss some more features of the parseLab protocol specification](./MAVLink_protocol_specification.md) - some of which allow for better control over the test messages that are generated.
